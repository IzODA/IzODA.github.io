/**
 * create-package-table.js
 * 
 * This script fetches the metadata of all packages availabe to the IzODA channel
 * on anaconda's webpage. It allows users to search by package name and language. It
 * also supports sorting by label/release level and language/tool. An environment script
 * generation button is included.
 */

// Change Link to IzODA Home
const homeLink = document.getElementsByClassName("icon-home")[0];
homeLink.href = "https://izoda.github.io";
homeLink.innerText = "IzODA Home Page";

let latestText = [];
// This file is generated by the internal webscrape tool
const latestReleaseName = "LATEST";
const packageFileDir = "https://izoda.github.io/";
// Start with default main label
let labelArray = ["main"];
const table = document.getElementById("packageTable");

/**
 * This function iterates through the labels of each package
 * and adds each label as an option to the labelSelect
 */
function addLabelOptions() {
  const labelSelect = document.getElementById("packageSelect");
  const labelArrayLength = labelArray.length;
  for (let i = 1; i < labelArrayLength; i++) {
    const labelOption = document.createElement("option");
    labelOption.text = labelArray[i];
    labelSelect.add(labelOption);
  }
}

/**
 * Loads the package table from https://izoda.github.io/LATEST
 * @param file is the static LATEST file
 */
function loadPackageTableFromFile(file) {
  let rawFile = new XMLHttpRequest();
  rawFile.open("GET", file);
  rawFile.onreadystatechange = () => {
    if (rawFile.readyState === 4) {
      if (rawFile.status === 200 || rawFile.status == 0) {
        let allText = rawFile.responseText;
        let splitLines = allText.split("\n");

        allText = getPackageTableHeader();

        // Indexes of each value
        const packageName = 5;
        const version = 7;
        const license = 1;
        const description = 3;
        const label = 11;
        const url = 9;

        // LATEST gets split by each "," which is then pushed into an array
        for (let lineIdx = 0; lineIdx < splitLines.length; lineIdx++) {
          if (splitLines[lineIdx].length == 0)
            continue;

          let finalVersion;
          
          let splitVals = splitLines[lineIdx].split("\"", );
          if (splitVals[version].includes(",")) {
            let splitVersions = splitVals[version].split(",");
            finalVersion = splitVersions[0];
            for (let i = 1; i < splitVersions.length; i++) {
              finalVersion += ", " + splitVersions[i];
            }
          } else {
            finalVersion = splitVals[version];
          }

          // Language is defined by the "py", "r-", or the lack of either meaning it is a tool
          const fullUrl = splitVals[url];
          const pkgName = splitVals[packageName];
          const lastPkgNameIndex = fullUrl.lastIndexOf(pkgName);
          const splitUrl = fullUrl.substring(lastPkgNameIndex + pkgName.length);

          let language;
          if (splitUrl.includes("py"))
            language = "Python";
          else if (splitUrl.includes("r-"))
            language = "R-lang";
          else
            language = "Tool"

          let packageArray = [pkgName, finalVersion, splitVals[license], splitVals[description], splitVals[label], splitVals[url], language];
          let labelSplit = splitVals[label].split(',');

          for (let i = 0; i < labelSplit.length; i++) {
            if (!labelArray.includes(labelSplit[i]))
              labelArray.push(labelSplit[i])
          }

          allText += getPackageTableEntry(packageArray);
        }

        addLabelOptions();
        tableBody = document.getElementById("packageTableBody");
        tableBody.innerHTML = allText;
      }
    }
  }
  rawFile.send(null);
}

/**
 * Returns the table row entry
 * @param packageArray - packageName, version, license, description, download URL
 */
function getPackageTableEntry(packageArray) {
  return "<tr><td><a href=\"https://anaconda.org" + packageArray[5] + "\">" + packageArray[0] + "</a></td><td>" + packageArray[1] +
    "</td><td>" + packageArray[2] + "</td><td>" + packageArray[3] + "</td><td>" + packageArray[6] + "</td><td>" + packageArray[4] + "</td></tr>";
}

/**
 * Creates the package table headers
 */
function getPackageTableHeader() {
  return "<thead>" + getPackageHeaderRow() + "</thead>";
}

/**
 * Helper function for getPackageTableHeader
 * Creates package table row and headers
 */
function getPackageHeaderRow() {
  return "<tr><th>Package</th><th>Version</th><th>License</th><th>Description</th><th>Language</th><th>Label</th>";
}

/**
 * Allows users to search for package names and languages/tool
 */ 
function searchBoxChange() {
  const searchText = document.getElementById("searchBox").value.toLowerCase();
  const tr = table.tBodies[0].getElementsByTagName("tr");
  // Loop through all table rows, and hide those who don't match the search query
  for (i = 0; i < tr.length; i++) {
    const pkgNameTd = tr[i].getElementsByTagName("td")[0];
    const languageTd = tr[i].getElementsByTagName("td")[4];
    if (pkgNameTd || languageTd) {
      if (pkgNameTd.innerHTML.toLowerCase().includes(searchText) || languageTd.innerHTML.toLowerCase().includes(searchText)) {
        tr[i].style.display = "";
      } else {
        tr[i].style.display = "none";
      }
    }
  }
}

/**
 * Allows users to sort packages by labels
 */
function labelChange() {
  const searchText = document.getElementById("packageSelect").value.toLowerCase();
  const tr = table.tBodies[0].getElementsByTagName("tr");
  // Loop through all table rows, and hide those who don't match the search query
  for (i = 0; i < tr.length; i++) {
    td = tr[i].getElementsByTagName("td")[5];
    if (td) {
      if (td.innerHTML.toLowerCase().includes(searchText)) {
        tr[i].style.display = "";
      } else {
        tr[i].style.display = "none";
      }
    }
  }
}

/**
 * Allows users to sort packages by language / tool
 */
function languageChange() {
  const searchText = document.getElementById("languageSelect").value.toLowerCase();
  const tr = table.tBodies[0].getElementsByTagName("tr");
  // Loop through all table rows, and hide those who don't match the search query
  for (i = 0; i < tr.length; i++) {
    td = tr[i].getElementsByTagName("td")[4];
    if (td) {
      if (td.innerHTML.toLowerCase().includes(searchText)) {
        tr[i].style.display = "";
      } else {
        tr[i].style.display = "none";
      }
    }
  }
}

/**
 * Generate a conda install script using the packageName and version
 */
function generateInstallScript() {
  let tr = table.tBodies[0].getElementsByTagName("tr");
  let script = "";
  let currentLine = "conda install";
  // Loop through all table rows and generate
  for (i = 0; i < tr.length; i++) {
    let name = tr[i].getElementsByTagName("td")[0];
    name = name.innerHTML;
    name = name.split(">");
    name = name[1].split("<")
    let version = tr[i].getElementsByTagName("td")[1];
    if (name && version) {
      if (name.innerHTML !== "conda") {
        if (currentLine.length >= 80) {
          script = script + currentLine + " \\\n";
          currentLine = "";
        }
        currentLine = currentLine + " " + name[0] + "=" + version.innerHTML.replace("v", "");
      }
    }
  }
  script += currentLine;
  download("condaInstall" + latestReleaseName + ".sh", script);
}

/**
 * Downloads the conda install script
 * @param filename the name of the file i.e. condaInstallRelease1.sh
 * @param text the script being added to the file
 */
function download(filename, text) {
  const element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

loadPackageTableFromFile(packageFileDir + latestReleaseName);